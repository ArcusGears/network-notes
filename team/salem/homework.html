<!DOCTYPE html>
<html>
<head>
<title>
CSC-317 Notes
</title>
</head>
<body>
<button onclick = "oc(822)">1.5-1.8 Notes</button>
<button onclick = "oc(823)">2.1-2.2 Notes</button>
<button onclick = "oc(824)">2.37-2.5 Notes</button>
<button onclick = "oc(825)">2.6-2.8 Notes</button>
<button onclick = "oc(826)">3.1-3.3 Notes</button>
<button onclick = "oc(827)">3.4-3.5 Notes</button>
<button onclick = "oc(828)">3.6-3.8 Notes</button>
<button onclick = "oc(829)">4.1-4.3 Notes</button>
<style>
body{background-color:#7FFFD4}
</style>
<div id = "822" style = "display:none">
    <h1>1.5-1.8 Notes</h1>
	<ul>
		<li>1961 to 1972</li>
			<ul>
				<li>Leonard Kleinrock</li>
				<ul>
					<li>The first published work on packet-switching techniques</li>
					<li>He used queuing theory to demonstrated the effectiveness of the packet-switching approach for bursty traffic sources.</li>
				</ul>
				<li>Paul Baran</li>
				<ul>
					<li>worked at the National Physical Laboratory in England</li>
					<li>investigated the use of packet switching for secure voice over military networks</li>
				</ul>
			</ul>
		<li>1972 to 1980</li>
		<ul>
			<li>Norman Abramson</li>
				<ul>
					<li>developing ALOHAnet, a packet-based radio network that allowed multiple remote sites on the Hawaiian Islands to communicate with each other</li>
					<li>The program was the first multiple-access protocol, allowing geographically distributed users to share a single broadcast communication medium (a radio frequency).</li>
				</ul>
			<li>Vinton Cerf and Robert Kahn</li>
				<ul>
					<li>They worked on interconnecting networks (under the sponsorship of the Defense Advanced Research Projects Agency (DARPA)), in essence creating a network of networks</li>
					<li><a href = "https://en.wikipedia.org/wiki/Vint_Cerf">About Vinton Cerf</a></li>
					<li><a href = "https://en.wikipedia.org/wiki/Bob_Kahn">About Rovert Kahn</a></li>
				</ul>
			<li>Metcalfe and Boggs</li>
			<ul>
				<li>built on Abramson’s multiple-access protocol work when they developed the Ethernet protocol</li>
			</ul>
		</ul>
		<li>1980 to 1990</li>
		<ul>
			<li>Minitel project</li>
			<ul>
				<li>In the early 1980s the French launched the Minitel project.</li>
				<li>Used consisted of a public packet-switched network, Minitel servers, and inexpensive terminals with built-in low-speed modems.</li>
				<li>Succeeded in 1984</li>
				<li>Included free sites—such as a telephone directory site—as well as private sites, which collected a usage-based fee from each user.</li>
				<li>Was in a large proportion of French homes 10 years before most Americans had ever heard of the Internet.</li>
			</ul>
		</ul>
		<li>1990s</li>
		<ul>
			<li>Tim Berners-Lee</li>
				<li>Worked at CERN</li>
				<li>developed initial versions of HTML, HTTP, a Web server, and a browser based on ideas originating in earlier work on hypertext from</li>
			<ul>
				<li>Vannevar Bush (1940s)</li>
				<li>Ted Nelson (1960s)</li>
			</ul>
		</ul>
	</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
</div>


<div id = "823" style  ="display:none">
	<h1>2.1-2.2 Notes</h1>
		<ul>
			<li><h2>P2P(Peer To Peer)</h2></li>
			<li>future challenges:
			<ul>
				<li>ISP Friendly: If switching from downstream to upstream will change from server to redsidential ISP, so there will be significant pressure on ISPs.</li>
				<li>Security: because P2P is so open and highly distributed, so securing it will be difficult.</li>
				<li>Incentives: volunteers supply the bandwidth, storyage, and computation resources to application, so their might be a challenge in incentive design.</li>
			</ul>


			<li><h2>process</h2></li>
			<ul>
				<li>can be thought of as a program that is running within an end system.</li>
			</ul>


			<li><h2>client and server</h2></li>
			<ul>
				<li>browser is a client process.</li>
				<li>Web server is a server process.</li>
			</ul>


			<li><h2>socket</h2></li>
			<ul>
				<li>When a process wants to send a message to antoher process on another host, it shoves the message out its socket.</li>
			</ul>


			<li><h2>IP address</h2></li>
			<ul>
				<li>the host identified</li>
			</ul>


			<li><h2>Services along four dimensions:</h2></li>
			<ul>


			<li><h3>Reliable Data Transfer</h3></li>
			<ul>
				<li>a transport-layer protocol can potentially provide to an application is process-to-process reliable data transfer.  However, there is a loss-tolerant applications that may not arrive but that is acceptable.</li>
			</ul>


			<li><h2>Throughput</h2></li>
			<ul>
				<li>rate at which the sending process can deliver bits to the receiving process.</li>
			</ul>


			<li><h2>Timing</h2></li>
			<ul>
				<li>a transport-layer protocol can guarantee that time contraints on data delivery will be achieved.</li>
			</ul>


			<li><h2>Security</h2></li>
			<ul>
				<li>A transport protocol can provide an application with one or more security services.</li>
			</ul>

			</ul>
		</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>

<div id = "824" style  ="display:none">
	<h1>2.37-2.5 Notes</h1>
		<ul>
			<li><h2>SMTP</h2></li>
			<ul>
				<li>Once the SMTP client and server have introduced themselves to each other, the client sends the message. SMTP can count on the reliable data transfer service of TCP to get the message to the server without errors. The client then repeats this process over the same TCP connection if it has other messages to send to the server; otherwise, it instructs TCP to close the connection.
</li>

				<li>SMTP uses persistent connections</li>
			</ul>
			<li><h2>HTTP comparing SMTP</h2></li>
			<ol>
				<li><ul><li>HTTP transfers files (also called objects) from a Web server to a Web client (typically a browser)</li>
				<li>SMTP transfers files (that is, e-mail messages) from one mail server to another mail server.</li></ul></li>
				
				<hr>


				<li><ul><li>HTTP is mostly uses the pull protocol:</li>
					<ul><li>someone loads information on a Web server and users use HTTP to pull the information from the server at their convenience.</li></ul>
				<li>SMTP mostly uses the push protocal:</li>
					<ul><li>the sending mail server pushes the file to the receiving mail server.</li></ul>
				<li>They both use TCP to initialize the connection.</li>
				</ul></li>

				<hr>


				<li><ul><li>SMTP requires each message, including the body of each message, to be in 7-bit ASCII format.  If the message is not in 7-bit ASCII format, then the message has to be encoded into 7-bit ASCII.</li>
				<li>HTTP data does not impose this restriction</li>
				</ul></li>

				<hr>

			<li><ul>
				<li>HTTP encapsulates each object in its own HTTP response message.</li>
				<li>SMTP places all of objects that belongs to the message into one message.</li>
			</li></ul>
			</ol>
		</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>



<div id = "825" style  ="display:none">
	<h1>2.6-2.8 Notes</h1>
		<h2>TCP vs UDP</h2>
		<h3>UDP client</h3>
		<div>from socket import *<br>serverName = &#39hostname&#39<br>serverPort = 12000<br>clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)<br>message = raw_input(&#39Input lowercase sentence:&#39)<br>clientSocket.sendto(message,(serverName, serverPort))<br>modifiedMessage, serverAddress = clientSocket.recvfrom(2048)<br>print modifiedMessage<br>clientSocket.close()<br></div>


<div>from socket import *</div>
<ul>
	<li>The socket module forms the basis of all network communications in Python. By
including this line, we will be able to create sockets within our program.</li>

</ul>

<div>serverName = &#39hostname&#39<br>serverPort = 12000<br></div>
<ul>
	<li>The first line sets the string serverName to hostname. Here, we provide a string
containing either the IP address of the server (e.g., &#34128.138.32.126&#34) or the hostname
of the server (e.g., &#34cis.poly.edu&#34). If we use the hostname, then a DNS lookup
will automatically be performed to get the IP address.) The second line sets the integer
variable serverPort to 12000.</li>

</ul>

<div>clientSocket = socket(socket.AF_INET, socket.SOCK_DGRAM)</div>
<ul>
	<li>This line creates the client’s socket, called clientSocket. The first parameter indicates the address family; in particular, AF_INET indicates that the underlying
network is using IPv4.  The second parameter indicates that the socket is of type SOCK_DGRAM, which means it is a UDP socket (rather than a TCP socket). Note that we are not specifying the port number of the client socket when we create it; we are instead letting
the operating system do this for us.</li>

</ul>


<div>message = raw_input(&#39Input lowercase sentence:&#39)</div>
<ul>
	<li>raw_input() is a built-in function in Python. When this command is executed,
the user at the client is prompted with the words “Input data:” The user then uses her
keyboard to input a line, which is put into the variable message. Now that we have
a socket and a message, we will want to send the message through the socket to the
destination host.</li>

</ul>


<div>clientSocket.sendto(message,(serverName, serverPort))</div>
<ul>
	<li>In the above line, the method sendto() attaches the destination address
(serverName, serverPort) to the message and sends the resulting packet into
the process&#39s socket, clientSocket. (As mentioned earlier, the source address is
also attached to the packet, although this is done automatically rather than explicitly
by the code.) Sending a client-to-server message via a UDP socket is that simple!
After sending the packet, the client waits to receive data from the server.</li>

</ul>

<div>modifiedMessage, serverAddress = clientSocket.recvfrom(2048)</div>
<ul>
	<li>With the above line, when a packet arrives from the Internet at the client&#39s socket, the packet&#39s data is put into the variable modifiedMessage and the packet&#39s source address is put into the variable serverAddress. The variable
serverAddress contains both the server&#39s IP address and the server&#39s port
number. The program UDPClient doesn&#39t actually need this server address information,
since it already knows the server address from the outset; but this line of
Python provides the server address nevertheless. The method recvfrom also
takes the buffer size 2048 as input. (This buffer size works for most purposes.)</li>

</ul>

<div>print modifiedMessage</div>
<ul>
	<li>This line prints out modifiedMessage on the user’s display. It should be the original line that the user typed, but now capitalized.</li>

</ul>

<div>clientSocket.close()</div>
<ul>
	<li>This line closes the socket. The process then terminates.</li>

</ul>


<h3>UDP Server</h3>
<div>from socket import *<br>serverPort = 12000<br>serverSocket = socket(AF_INET, SOCK_DGRAM)<br>serverSocket.bind((&#39&#39, serverPort))<br>print &#34The server is ready to receive&#34<br>while 1:<br><ul><li>message, clientAddress = serverSocket.recvfrom(2048)</li><li>modifiedMessage = message.upper()</li><li>serverSocket.sendto(modifiedMessage, clientAddress)</li></ul></div>


<div>serverSocket.bind((&#39&#39, serverPort))</div>
<ul>
	<li>The above line binds (that is, assigns) the port number 12000 to the server’s socket. Thus in UDPServer, the code (written by the application developer) is explicitly assigning a port number to the socket. In this manner, when anyone sends a packet to port 12000 at the IP address of the server, that packet will be directed to this
socket. UDPServer then enters a while loop; the while loop will allow UDPServer
to receive and process packets from clients indefinitely. In the while loop,
UDPServer waits for a packet to arrive.</li>

</ul>

<div>message, clientAddress = serverSocket.recvfrom(2048)</div>
<ul>
	<li>This line of code is similar to what we saw in UDPClient. When a packet arrives at the server&#39s socket, the packet&#39s data is put into the variable message and the packet&#39s source address is put into the variable clientAddress. The variable
clientAddress contains both the client&#39s IP address and the client&#39s port number.
Here, UDPServer will make use of this address information, as it provides a return
address, similar to the return address with ordinary postal mail. With this source
address information, the server now knows to where it should direct its reply.</li>

</ul>

<div>modifiedMessage = message.upper()</div>
<ul>
	<li>This line is the heart of our simple application. It takes the line sent by the client and uses the method upper() to capitalize it.</li>

</ul>

<div>serverSocket.sendto(modifiedMessage, clientAddress)</div>
<ul>
	<li>This last line attaches the client’s address (IP address and port number) to the capitalized message, and sends the resulting packet into the server’s socket. (As mentioned earlier, the server address is also attached to the packet, although this is done automatically rather than explicitly by the code.)</li>

</ul>


<h3>TCP Client</h3>
<div>from socket import *<br>serverName = &#39servername&#39<br>serverPort = 12000<br>clientSocket = socket(AF_INET, SOCK_STREAM)<br>clientSocket.connect((serverName,serverPort))<br>sentence = raw_input(&#39Input lowercase sentence:&#39)<br>clientSocket.send(sentence)<br>modifiedSentence = clientSocket.recv(1024)<br>print &#39From Server:&#39, modifiedSentence<br>clientSocket.close()<br></div>

<div>clientSocket = socket(AF_INET, SOCK_STREAM)</div>
<ul>
	<li>This line creates the client’s socket, called clientSocket. The first parameter again indicates that the underlying network is using IPv4. The second parameter
indicates that the socket is of type SOCK_STREAM, which means it is a TCP socket
(rather than a UDP socket). Note that we are again not specifying the port number of the client socket when we create it; we are instead letting the operating system
do this for us.</li>

</ul>


<div>clientSocket.connect((serverName,serverPort))</div>
<ul>
	<li>Recall that before the client can send data to the server (or vice versa) using a TCP socket, a TCP connection must first be established between the client and server. The above line initiates the TCP connection between the client and server. The
parameter of the connect() method is the address of the server side of the connection.
After this line of code is executed, the three-way handshake is performed
and a TCP connection is established between the client and server.</li>

</ul>

<div>sentence = raw_input(&#39Input lowercase sentence:&#39)</div>
<ul>
	<li>As with UDPClient, the above obtains a sentence from the user. The string sentence continues to gather characters until the user ends the line by typing a carriage return. The next line of code is also very different from UDPClient:</li>

</ul>

<div>clientSocket.send(sentence)</div>
<ul>
	<li>The above line sends the string sentence through the client&#39s socket and into the TCP connection. Note that the program does not explicitly create a packet and attach the destination address to the packet, as was the case with UDP sockets. Instead the client program simply drops the bytes in the string sentence into the TCP connection.
The client then waits to receive bytes from the server.</li>

</ul>

<div>modifiedSentence = clientSocket.recv(2048)</div>
<ul>
	<li>When characters arrive from the server, they get placed into the string modifiedSentence. Characters continue to accumulate in modifiedSentence until the
line ends with a carriage return character. After printing the capitalized sentence, we
close the client’s socket:</li>

</ul>

<div>clientSocket.close()</div>
<ul>
	<li>This last line closes the socket and, hence, closes the TCP connection between the client and the server. It causes TCP in the client to send a TCP message to TCP in the server </li>

</ul>

<h3>TCP Server</h3>

<div>from socket import *<br>serverPort = 12000<br>serverSocket = socket(AF_INET,SOCK_STREAM)<br>serverSocket.bind((&#39&#39,serverPort))<br>serverSocket.listen(1)<br>print &#39The server is ready to receive&#39<br>while 1:<br><ul><li>connectionSocket, addr = serverSocket.accept()</li><li>sentence = connectionSocket.recv(1024)</li><li>capitalizedSentence = sentence.upper()</li><li>connectionSocket.send(capitalizedSentence)</li><li>connectionSocket.close()</li></ul></div>

<div>serverSocket=socket(AF_INET,SOCK_STREAM)</div>
<ul>
	<li>Similar to UDPServer, we associate the server port number, serverPort, with
this socket:</li>

</ul>

<div>serverSocket.bind((&#39&#39,serverPort))</div>
<ul>
	<li>But with TCP, serverSocket will be our welcoming socket. After establishing
this welcoming door, we will wait and listen for some client to knock on the
door:</li>

</ul>

<div>serverSocket.listen(1)</div>
<ul>
	<li>This line has the server listen for TCP connection requests from the client. The
parameter specifies the maximum number of queued connections (at least 1).</li>

</ul>


<div>connectionSocket, addr = serverSocket.accept()</div>
<ul>
	<li>When a client knocks on this door, the program invokes the accept() method for serverSocket, which creates a new socket in the server, called connectionSocket,
dedicated to this particular client. The client and server then complete
the handshaking, creating a TCP connection between the client’s clientSocket
and the server’s connectionSocket. With the TCP connection established, the
client and server can now send bytes to each other over the connection. With TCP, all
bytes sent from one side not are not only guaranteed to arrive at the other side but also
guaranteed arrive in order.</li>

</ul>


<div>connectionSocket.close()</div>
<ul>
	<li>In this program, after sending the modified sentence to the client, we close the connection socket. But since serverSocket remains open, another client can now
knock on the door and send the server a sentence to modify</li>

</ul>


<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>




<!-- This is a nice formate to just copy and paste into your page
			<li> -- This is merely to show how everything would be alined.


			<li><h2></h2></li>
			<ul>
				<li></li>
			</ul>

-->

<!--<div></div>
<ul>
	<li></li>

</ul>

-->



<!-- All of this information is from Computer Networking: Top-Down Approach (w/Access Code) Edition: 6th and other sources -->
<!-- style="height:3px;border:none;color:#333;background-color:#333;" was taken from http://stackoverflow.com/questions/4151743/how-i-change-the-thickness-of-my-hr-tag  and I take no credit!
-->

<div id = "826" style = "display:none">
    <h1>3.1-3.3 Notes</h1>
<h2>Demultiplexing</h2>
<ul><li>At the receiving end, the transport layer examines these fields to identify the receiving socket and then directs the segment to that socket. This job of delivering the data in a transport&#45layer segment to the correct socket is called demultiplexing.
</li></ul>
<h2>Multiplexing</h2>
<ul><li>The job of gathering data chunks at the source host from different sockets, encapsulating each data chunk with header information (that will later be used in demultiplexing) to create segments, and passing the segments to the network layer is called multiplexing.
</li></ul>
<h2>UDP rather than over TCP</h2>
<ul>
<li><h3>Finer application-level control over what data is sent, and when:</h3></li>
<ul><li>Under UDP, as soon as an application process passes data to UDP, UDP will package the data inside a UDP segment and immediately pass the segment to the network layer. TCP, on the other hand, has a congestion-control mechanism that throttles the transport-layer TCP sender when one or more links between the source and destination hosts become excessively congested. TCP will also continue to resend a segment until the receipt of the segment has been acknowledged by the destination, regardless of how long reliable delivery takes. Since real-time applications often require a minimum sending rate, do not want to overly delay segment transmission, and can tolerate some data loss, TCP's service model is not particularly well matched to these applications' needs. As discussed below, these applications can use UDP and implement, as part of the application, any additional functionality that is needed beyond UDP's no-frills segment-delivery service.</li></ul>
<li><h3>No connection establishment:</h3></li>
<ul><li>As we'll discuss later, TCP uses a three-way handshake before it starts to transfer data. UDP just blasts away without any formal preliminaries. Thus UDP does not introduce any delay to establish a connection. This is probably the principal reason why DNS runs over UDP rather than TCP, DNS would be much slower if it ran over TCP. HTTP uses TCP rather than UDP, since reliability is critical for Web pages with text. But, as we briefly discussed in Section 2.2, the TCP connection-establishment delay in HTTP is an important contributor to the delays associated with downloading Web documents.</li></ul>
<li><h3>No Connection Stat</h3></li>
<ul><li>TCP maintains connection state in the end systems. This connection state includes receive and send buffers, congestion-control parameters, and sequence and acknowledgment number parameters. We will see in Section 3.5 that this state information is needed to implement TCP's reliable data transfer service and to provide congestion control. UDP, on the other hand, does not maintain connection state and does not track any of these parameters. For this reason, a server devoted to a particular application can typically support many more active clients when the application runs over UDP rather than TCP.</li></ul>
<li><h3>Small Packet Header Overhead</h3></li>
<ul><li>The TCP segment has 20 bytes of header overhead in every segment, whereas UDP has only 8 bytes of overhead.</li></ul>
</ul>
<hr style="height:3px;border:none;color:#333;background-color:#333;">
</div>


<div id = "827" style  ="display:none">
	<h1>3.4-3.5 Notes</h1>
<h2>Reliable Data Transfer over a Perfectly Reliable Channel</h2>
<h4>finite-state machine (FSM):</h4> <ul><li>is a mathematical model of computation used to design both computer programs and sequential logic circuits.</li></ul>
<h2>The different FSM</h2>
		<ul>
			<li><h3>rdt1.0</h3></li>
				<ul><li>sender and receiver.  Just one state.</li><li>Just one state</li><li>Perfectly reliable because nothing can go wrong.</li></ul>
		</ul>
<div>Problem: <i>what if a packet is corrupted.</i></div>
		<ul>
			<li><h3>rdt2.0</h3></li>
				<ul><li>positive acknowledgments and negative acknowledgments</li><li> reliable data transfer protocols based on such retransmission are known as ARQ (Automatic Repeat reQuest) protocols.<ul><li>Error detection.</li><li>Receiver feedback.</li><li>Retransmission.</li></ul></li><li>Sender sidew with two states:</li><ul><li>Waiting for data to be passed down.</li><li>Waiting for an ACK or a NAK packet from the receiver.</li></ul><li>Receiver:</li><ul><li>Save the data, then send ACK if the packet is not corrupted.  Other wise, send NAK.</li></ul></ul>
		</ul>
<div>Problem: <i>what if the ACK or NAK packet is corrupted.</i></div>

		<ul>
			<li><h3>rdt2.1</h3></li>
				<ul><li>add a new field to the data packet and
have the sender number its data packets by putting a sequence number into this
field.  1-bit sequence number will suffice, since it will allow the receiver
to know whether the sender is resending the previously transmitted packet</li></ul>
		</ul>
<img src = "rdt21.png" style = "border:3px solid black;">
<img src = "rdt21r.png" style = "border:3px solid black;">
		<ul>
			<li><h3>rdt2.2</h3></li>
				<ul><li>is that the receiver must
now include the sequence number of the packet being acknowledged by an ACK
message (this is done by including the ACK,0 or ACK,1 argument in make_pkt()
in the receiver FSM), and the sender must now check the sequence number of the
packet being acknowledged by a received ACK message.</li></ul>
		</ul>
<div>Problem: <i>What if the packet is lost.</i></div>
		<ul>
			<li><h3>rdt3.0</h3></li>
				<ul><li>Modifying sender.</li><li>Countdown Timer, thus need to be able to</li><ol><li>start the timer each time a packet is sent.</li><li>respond to a timer interrupt.</li><li>stop the timer.</li></ol></ul>


</ul>






<img src = "rdt22r.png" style = "border:3px solid black;">
<img src = "rdt30.png" style = "border:3px solid black;">


<!--put the burden of detecting and recovering from lost packets on the sender.
--The approach thus adopted in practice is for the
sender to judiciously choose a time value such that packet loss is likely, although
not guaranteed, to have happened.
--This introduces the possibility of duplicate data packets in the sender-to-receiver channel.
--rdt2.2 already has enough
functionality (that is, sequence numbers) to handle the case of duplicate packets.
--mechanism requires a countdown timer that can
interrupt the sender after a given amount of time has expired. The sender will thus
need to be able to (1) start the timer each time a packet (either a first-time packet or
a retransmission) is sent, (2) respond to a timer interrupt (taking appropriate
actions), and (3) stop the timer.
-->

<ul>

<li><h4>Fun Facts</h4></li><ul><li><div style = "margin-bottom:30px">Problem: <i>duplicate data packets</i>.  Solution: <i>rdt2.2 already has enough
functionality (that is, sequence numbers) to handle the case of duplicate packets</i>.</div></li><li><div style = "margin-bottom:30px">Because packet sequence numbers alternate between 0 and 1, protocol
rdt3.0 is sometimes known as the <b>alternating-bit protocol</b>.</div></li><li><div style = "margin-bottom:30px">These are known as stop-and-wait protocols.</div></li></ul>

</ul>



<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>


<div id = "828" style  ="display:none">
	<h1>3.6-3.8 Notes</h1>
<h2>Congestion-Control Algorithms</h2>

<ul><li><h3>Slow Start</h3></li>
<ul>
	<li>cwnd (The congestion window, which imposes a constraint on the rate at which a TCP sender can send traffic into the network.) begins at 1 MSS and increases by 1 MSS every time a transmitted segment is first acknowledged.
</li>
	<li>TCP sends the first segment into the network and waits for an acknowledgment. When this acknowledgment arrives, the TCP sender increases the congestion window by one MSS and sends out two maximum-sized segments.</li>
</ul>
<div style = "margin-top:10px;margin-bottom:10px;"><i>When should this exponential growth end? Slow start provides several answers to this question</i>.</div>

<ol>
	<li>If there is a loss event (i.e., congestion) indicated by a timeout</li>
	<li>When slow start hits the ssthresh, then it stops doubling and transitions into congestion avoidance mode (TCP increases cwnd more cautiously when in congestion-avoidance mode).</li>
	<li>When three duplicate ACKs are detected, in which case TCP performs fast retransmit and enters the fast recovery state.</li>
</ol>

<img src = "ss.png" style = "border:2px solid black;margin-top:20px;">

<li><h3>Congestion Avoidance</h3></li>

<ul>
	<li>Increases the value of cwnd by just a single MSS every RTT</li>
	<li>Example:</li>
	<ul><li>if MSS (Maximum Segment Size) is 1,460 bytes and cwnd is 14,600 bytes, then 10 segments are being sent within an RTT (Round-Trip Time). Each arriving ACK (assuming one ACK per segment) increases the congestion window size by 1/10 MSS, and thus, the value of the congestion window will</li></ul>
	<li>triple duplicate ACKs received</li>
	<ul>
		<li>value of ssthresh to be half the value of cwnd when the triple duplicate ACKs were received.  Then fast-recovery state is then entered.</li>
	</ul>
</ul>

<img src = "fast.png" style = "border:2px solid black;margin-top:20px;">

<li><h3>Fast Recovery</h3></li>
<ul>
	<li>TCP Tahoe</li>
	<ul><li>cut its congestion window to 1 MSS and entered the slow-start phase after either a timeout-indicated or triple-duplicate-ACK-indicated loss event.</li></ul>
	<li>TCP Reno</li>
	<ul><li>Incorported fast recovery</li>
		<li>newer version of TCP</li>
		<li>threshold is initially equal to 8 MSS.</li></ul>
	<li>Example</li>
	<ul>
		<li>For the first eigth transmission reounds, Tahoe and Reno take identical actions.</li>
		<li>The congestion window then climbs linearly until a triple duplicateACK event occurs, just after transmission round 8.</li>
		<li>Triple duplicate ACK is detected</li>
		<li>Under TCP Reno, the congestion window is set to cwnd = 6 X MSS and then grows linearly.</li>
		<li>Under TCP Tahoe, the congestion window is set to 1 MSS and grows exponentially until it reaches the value of ssthresh, at which point it grows linearly.</li></ul>
</ul>

<img src = "congestion.png" style = "border:2px solid black;margin-top:20px;">


</ul>

<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>



<div id = "829" style  ="display:none">
	<h1>4.1-4.3 Notes</h1>
<h2>Router</h2>
<ul>
	<li>Forwarding: refers to the router-local action of transferring a packet from an input link interface to the appropriate output link interface.</li>
	<li>Routing: refers to the network-wide process that determines the end-to-end paths that packets take from source to destination.</li>
	<li>forwarding table: examine the packet header, get an index for that and pushes it to the outgoing link interface to shich the packet is to be forwarded.</li>
	<li><h3>Input Processing</h3></li>
		<ul>
			<li>The forwarding table is computed and updated
by the routing processor, with a shadow copy typically stored at each input port.</li>
			<li>And if the switch fabric is not used, then it will be passed onto the switch fabric.</li>
		</ul>
	<li><h3>Switch fabric</h3></li>
		<ul>
			<li><h4>Switching via memory:</h4></li>
			<ul>
				<li>switching between input and output ports being done under direct control of the CPU (routing processor).</li>
				<li> Input and output ports functioned as traditional I/O
devices in a traditional operating system.</li>
				<li>The packet was then copied
from the input port into processor memory.</li>
				<li>the router extracts the destination address and then looks up the direction from the forwarding table.  After that, it sends the packet to the output's port buffer.</li>
				<li>And if the switch fabric is not used, then it will be passed onto the switch fabric.</li>

			</ul>
			<li><h4>Swithcing via a bus</h4></li>
			<ul>
				<li>an input port transfers a packet directly to the
output port over a shared bus, without intervention by the routing processor.</li>
				<li>by having the input port pre-pend a switch-internal label (header) to the packet indicating the local output port to which this packet is being transferred and transmitting the packet onto the bus.</li>
				<li>The packet is received by all output ports, but only the port that matches the label will keep the packet.</li>
				<li>label is then removed at the output port</li>
				<li>If there are multiplies arriving at the same time, then they go one at a time because each packet can cross the bus one at a time.</li>
				<li>bus is often sufficient for
routers that operate in small local area and enterprise networks</li>


			</ul>
			<li><h4>Switching via an interconnection network.</h4></li>
				<ul>
					<li>A crossbar switch is an interconnection network consisting of 2N buses that connect N input ports to N output ports</li>
					<li>Each vertical bus intersects each horizontal bus at a crosspoint, which can be opened or closed at any time by the switch fabric controller</li>
				</ul>
		</ul>
<img src = "switch.png" style = "border:3px solid black; margin:15px">
	<li><h3>Output Processing</h3></li>
		<ul>
			<li>takes packets that have been stored in the output port’s memory and transmits them over the output link.</li>
		</ul>
		<li><h3>Routing Processor</h3></li>
<ul><li>maintains routing tables and attached link state information,
and computes the forwarding table for the router</li></ul>
</ul>

<hr style="height:3px;border:none;color:#333;background-color:#333;">
		
</div>




<script>
function oc(id){
	if(document.getElementById(id).style.display == "none"){
		document.getElementById(id).style.display = "block";
	} else {
		document.getElementById(id).style.display = "none";
	}
}
</script>
</body>
</html>

